use crate::{DynSolType, DynSolValue};
use alloc::{boxed::Box, string::String, sync::Arc, vec::Vec};
use alloy_primitives::{Address, B256, I256, U256};
use arbitrary::size_hint;
use proptest::{
    collection::VecStrategy,
    prelude::*,
    strategy::{Map, Recursive, TupleUnion},
};

const DEPTH: u32 = 8;
const DESIZED_SIZE: u32 = 64;
const EXPECTED_BRANCH_SIZE: u32 = 16;

#[derive(Debug, derive_arbitrary::Arbitrary)]
enum Choice {
    Bool,
    Int,
    Uint,
    Address,
    FixedBytes,
    // CustomValue,
    Bytes,
    String,

    Array,
    FixedArray,
    Tuple,
    // CustomStruct,
}

#[inline]
const fn bytes_size(n: usize) -> usize {
    (n % 31) + 1
}

#[inline]
const fn int_size(n: usize) -> usize {
    let n = (n % 255) + 1;
    n + (8 - (n % 8))
}

impl<'a> arbitrary::Arbitrary<'a> for DynSolType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value = match u.arbitrary::<Choice>()? {
            Choice::Bool => Self::Bool,
            Choice::Int => Self::Int(int_size(u.arbitrary()?)),
            Choice::Uint => Self::Uint(int_size(u.arbitrary()?)),
            Choice::Address => Self::Address,
            Choice::FixedBytes => Self::FixedBytes(bytes_size(u.arbitrary()?)),
            Choice::Bytes => Self::Bytes,
            Choice::String => Self::String,
            Choice::Array => Self::Array(u.arbitrary()?),
            Choice::FixedArray => Self::FixedArray(u.arbitrary()?, u.int_in_range(0..=64)?),
            Choice::Tuple => Self::Tuple(u.arbitrary()?),
        };
        Ok(value)
    }

    fn size_hint(depth: usize) -> (usize, Option<usize>) {
        if depth == DEPTH as usize {
            (0, Some(0))
        } else {
            size_hint::and(
                u32::size_hint(depth),
                size_hint::or_all(&[usize::size_hint(depth), Self::size_hint(depth + 1)]),
            )
        }
    }
}

#[inline]
#[allow(dead_code)]
fn arbitrary_string(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<String> {
    let len = u.arbitrary::<u8>()?;
    let mut s = String::with_capacity(len as usize);
    for _ in 0..len {
        s.push(u.int_in_range(b'a'..=b'z')? as char);
    }
    Ok(s)
}

// rustscript
type ValueOfStrategy<S> = <S as Strategy>::Value;

/// Tuple generated by `prop_oneof!`.
type UnionTuple<T> = (u32, Arc<T>);

type StratMap<S, T> = Map<S, fn(ValueOfStrategy<S>) -> T>;

type MappedTuple<S, T> = UnionTuple<StratMap<S, T>>;

type Rec<T, S> = Recursive<T, fn(BoxedStrategy<T>) -> S>;

// we must explicitly the final types of the strategies
type TypeRecurseStrategy = TupleUnion<(
    MappedTuple<BoxedStrategy<DynSolType>, DynSolType>, // Array
    MappedTuple<BoxedStrategy<DynSolType>, DynSolType>, // FixedArray
    MappedTuple<VecStrategy<BoxedStrategy<DynSolType>>, DynSolType>, // Tuple
)>;
type TypeStrategy = Rec<DynSolType, TypeRecurseStrategy>;

/*
type ValueRecurseStrategy = TupleUnion<(
    MappedTuple<VecStrategy<BoxedStrategy<DynSolValue>>, DynSolValue>, //Array
    MappedTuple<VecStrategy<BoxedStrategy<DynSolValue>>, DynSolValue>,
    // FixedArray
    MappedTuple<VecStrategy<BoxedStrategy<DynSolValue>>, DynSolValue>, // Tuple
)>;
*/
type ValueRecurseStrategy = StratMap<VecStrategy<BoxedStrategy<DynSolValue>>, DynSolValue>;
type ValueStrategy = Rec<DynSolValue, ValueRecurseStrategy>;

impl proptest::arbitrary::Arbitrary for DynSolType {
    type Parameters = (u32, u32, u32);
    type Strategy = TypeStrategy;

    #[inline]
    fn arbitrary() -> Self::Strategy {
        Self::arbitrary_with((DEPTH, DESIZED_SIZE, EXPECTED_BRANCH_SIZE))
    }

    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
        let (depth, desired_size, expected_branch_size) = args;
        Self::leaf().prop_recursive(depth, desired_size, expected_branch_size, Self::recurse)
    }
}

impl DynSolType {
    #[inline]
    fn leaf() -> impl Strategy<Value = Self> {
        prop_oneof![
            Just(Self::Bool),
            any::<usize>().prop_map(|x| Self::Int(int_size(x))),
            any::<usize>().prop_map(|x| Self::Uint(int_size(x))),
            Just(Self::Address),
            (1..=32usize).prop_map(Self::FixedBytes),
            Just(Self::Bytes),
            Just(Self::String),
        ]
    }

    #[inline]
    fn recurse(element: BoxedStrategy<Self>) -> TypeRecurseStrategy {
        prop_oneof![
            element.clone().prop_map(|ty| Self::Array(Box::new(ty))),
            element
                .clone()
                .prop_map(|ty| Self::FixedArray(Box::new(ty), 0)),
            prop::collection::vec(element, 1..=16).prop_map(Self::Tuple),
        ]
    }
}

impl proptest::arbitrary::Arbitrary for DynSolValue {
    type Parameters = (u32, u32, u32);
    type Strategy = ValueStrategy;

    #[inline]
    fn arbitrary() -> Self::Strategy {
        Self::arbitrary_with((DEPTH, DESIZED_SIZE, EXPECTED_BRANCH_SIZE))
    }

    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {
        let (depth, desired_size, expected_branch_size) = args;
        Self::leaf().prop_recursive(depth, desired_size, expected_branch_size, Self::recurse)
    }
}

impl DynSolValue {
    #[inline]
    fn leaf() -> impl Strategy<Value = Self> {
        prop_oneof![
            any::<bool>().prop_map(Self::Bool),
            any::<I256>().prop_map(|x| Self::Int(x, int_size(x.bits() as usize))),
            any::<U256>().prop_map(|x| Self::Uint(x, int_size(x.bit_len()))),
            any::<Address>().prop_map(Self::Address),
            any::<B256>()
                .prop_flat_map(|x| (Just(x), 1..=32usize))
                .prop_map(|(x, sz)| Self::FixedBytes(x, sz)),
            any::<Vec<u8>>().prop_map(Self::Bytes),
            any::<String>().prop_map(Self::String),
        ]
    }

    #[inline]
    fn recurse(element: BoxedStrategy<Self>) -> ValueRecurseStrategy {
        // prop_oneof![
        // TODO: Make arrays only generate one type of element
        // prop::collection::vec(element.clone(), 1..=16).prop_map(Self::Array),
        // prop::collection::vec(element.clone(), 1..=16).prop_map(Self::FixedArray),
        prop::collection::vec(element, 1..=16).prop_map(Self::Tuple)
        // ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    proptest!(
        #![proptest_config(ProptestConfig {
            cases: 1024,
            ..Default::default()
        })]

        #[test]
        fn fuzz_dyn_sol_value(value: DynSolValue) {
            let expected = value.as_type().expect("generated invalid type");
            // this shouldn't fail after the previous assertion
            let s = value.sol_type_name().unwrap();
            let data = value.encode_params();

            let ty: DynSolType = match s.parse() {
                Ok(ty) => {
                    prop_assert_eq!(&ty, &expected, "types don't match {:?}", s);
                    ty
                },
                Err(e) => {
                    prop_assert!(
                        false,
                        "failed to parse {s:?}: {e}\nvalue: {value:?}",
                    );
                    unreachable!();
                },
            };
            prop_assert_eq!(&ty, &expected, "types don't match");
            prop_assert_eq!(&ty.sol_type_name(), &s, "type strings don't match");

            match ty.decode_params(&data) {
                Ok(decoded) => prop_assert_eq!(
                    &decoded,
                    &value,
                    "decoded value doesn't match {:?}\ndata: {:?}",
                    s,
                    hex::encode_prefixed(&data),
                ),
                Err(e) => prop_assert!(
                    false,
                    "failed to decode {s:?}: {e}\nvalue: {value:?}\ndata: {:?}",
                    hex::encode_prefixed(&data),
                ),
            }
        }
    );
}
